<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/historical/HistoricalDataFetcher.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/historical/HistoricalDataFetcher.java" />
              <option name="originalContent" value="package historical;&#10;&#10;import java.io.IOException;&#10;import java.nio.file.Files;&#10;import java.nio.file.Paths;&#10;import java.net.http.HttpClient;&#10;import java.net.http.HttpRequest;&#10;import java.net.http.HttpResponse;&#10;import java.net.URI;&#10;import java.time.LocalDateTime;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;import com.google.gson.Gson;&#10;import com.google.gson.JsonObject;&#10;import com.google.gson.JsonArray;&#10;import model.CandleData;&#10;&#10;public class HistoricalDataFetcher {&#10;&#10;    private static final String API_BASE_URL = &quot;https://api.kite.trade&quot;;&#10;    private static final String API_KEY = &quot;kbn0ca43nbzamzga&quot;; // Replace with your actual API key&#10;    private String accessToken;&#10;&#10;    // Load access token from JSON file&#10;    public void loadAccessToken() throws IOException {&#10;        String jsonContent = Files.readString(Paths.get(&quot;login/access_token.json&quot;));&#10;        Gson gson = new Gson();&#10;        JsonObject jsonObject = gson.fromJson(jsonContent, JsonObject.class);&#10;        this.accessToken = jsonObject.get(&quot;access_token&quot;).getAsString();&#10;    }&#10;&#10;    // Fetch historical data for an instrument&#10;    public List&lt;CandleData&gt; fetchHistoricalData(String instrumentToken, String interval,&#10;                                                LocalDateTime fromDate, LocalDateTime toDate,&#10;                                                boolean includeContinuous, boolean includeOI) throws IOException, InterruptedException {&#10;&#10;        // Load access token&#10;        loadAccessToken();&#10;&#10;        // Format dates&#10;        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);&#10;        String fromDateStr = fromDate.format(formatter);&#10;        String toDateStr = toDate.format(formatter);&#10;&#10;        // Build URL&#10;        StringBuilder urlBuilder = new StringBuilder();&#10;        urlBuilder.append(API_BASE_URL)&#10;                .append(&quot;/instruments/historical/&quot;)&#10;                .append(instrumentToken)&#10;                .append(&quot;/&quot;)&#10;                .append(interval)&#10;                .append(&quot;?from=&quot;).append(fromDateStr.replace(&quot; &quot;, &quot;+&quot;))&#10;                .append(&quot;&amp;to=&quot;).append(toDateStr.replace(&quot; &quot;, &quot;+&quot;));&#10;&#10;        if (includeContinuous) {&#10;            urlBuilder.append(&quot;&amp;continuous=1&quot;);&#10;        }&#10;&#10;        if (includeOI) {&#10;            urlBuilder.append(&quot;&amp;oi=1&quot;);&#10;        }&#10;&#10;        // Create HTTP client and request&#10;        HttpClient client = HttpClient.newHttpClient();&#10;        HttpRequest request = HttpRequest.newBuilder()&#10;                .uri(URI.create(urlBuilder.toString()))&#10;                .header(&quot;X-Kite-Version&quot;, &quot;3&quot;)&#10;                .header(&quot;Authorization&quot;, &quot;token &quot; + API_KEY + &quot;:&quot; + accessToken)&#10;                .GET()&#10;                .build();&#10;&#10;        // Send request and get response&#10;        HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());&#10;&#10;        // Parse and display response&#10;        List&lt;CandleData&gt; candleDataList = null;&#10;        if (response.statusCode() == 200) {&#10;            Gson gson = new Gson();&#10;            JsonObject responseJson = gson.fromJson(response.body(), JsonObject.class);&#10;&#10;            if (responseJson.get(&quot;status&quot;).getAsString().equals(&quot;success&quot;)) {&#10;                JsonObject data = responseJson.getAsJsonObject(&quot;data&quot;);&#10;                JsonArray candles = data.getAsJsonArray(&quot;candles&quot;);&#10;&#10;                System.out.println(&quot;Historical Data for Instrument Token: &quot; + instrumentToken);&#10;                System.out.println(&quot;Interval: &quot; + interval);&#10;                System.out.println(&quot;From: &quot; + fromDateStr + &quot; To: &quot; + toDateStr);&#10;                System.out.println(&quot;Total Records: &quot; + candles.size());&#10;                System.out.println();&#10;&#10;                // Print headers&#10;                if (includeOI) {&#10;                    System.out.println(&quot;Timestamp\t\tOpen\tHigh\tLow\tClose\tVolume\tOI&quot;);&#10;                } else {&#10;                    System.out.println(&quot;Timestamp\t\tOpen\tHigh\tLow\tClose\tVolume&quot;);&#10;                }&#10;                System.out.println(&quot;**********************************************************************************************************&quot;);&#10;&#10;                candleDataList = new ArrayList&lt;&gt;();&#10;                // Print candle data&#10;                for (int i = 0; i &lt; candles.size(); i++) {&#10;                    JsonArray candle = candles.get(i).getAsJsonArray();&#10;&#10;                    long timestamp = candle.get(0).getAsLong();&#10;                    double open = candle.get(1).getAsDouble();&#10;&#10;                    double high = candle.get(2).getAsDouble();&#10;                    double low = candle.get(3).getAsDouble();&#10;                    double close = candle.get(4).getAsDouble();&#10;                    long volume = candle.get(5).getAsLong();&#10;&#10;                    CandleData candleData;// = new CandleData(open,high,low,close,volume,timestamp);&#10;&#10;                    if (includeOI &amp;&amp; candle.size() &gt; 6) {&#10;                        long oi = candle.get(6).getAsLong();&#10;                        System.out.printf(&quot;%s\t%.2f\t%.2f\t%.2f\t%.2f\t%d\t%d%n&quot;,&#10;                                timestamp, open, high, low, close, volume, oi);&#10;&#10;                        candleData = new CandleData(open, high, low, close, volume, oi, timestamp);&#10;                    } else {&#10;                        System.out.printf(&quot;%s\t%.2f\t%.2f\t%.2f\t%.2f\t%d%n&quot;,&#10;                                timestamp, open, high, low, close, volume);&#10;                        candleData = new CandleData(open, high, low, close, volume, 0L, timestamp);&#10;                    }&#10;&#10;                    candleDataList.add(candleData);&#10;                }&#10;            } else {&#10;                System.err.println(&quot;API Error: &quot; + responseJson.get(&quot;message&quot;).getAsString());&#10;            }&#10;        } else {&#10;            System.err.println(&quot;HTTP Error: &quot; + response.statusCode());&#10;            System.err.println(&quot;Response: &quot; + response.body());&#10;        }&#10;        return candleDataList;&#10;&#10;    }&#10;&#10;    // Main method with example usage&#10;    public static void main(String[] args) {&#10;        HistoricalDataFetcher fetcher = new HistoricalDataFetcher();&#10;&#10;        try {&#10;            // Example: Fetch minute data for a NIFTY futures contract&#10;            String instrumentToken = &quot;12517890&quot;; // Replace with actual instrument token&#10;            String interval = &quot;5minute&quot;; // minute, 3minute, 5minute, 10minute, 15minute, 30minute, 60minute, day&#10;&#10;            LocalDateTime fromDate = LocalDateTime.of(2025, 8, 20, 9, 15, 0);&#10;            LocalDateTime toDate = LocalDateTime.of(2025, 9, 11, 15, 30, 0);&#10;&#10;            // Fetch data with OI (for futures/options)&#10;            fetcher.fetchHistoricalData(instrumentToken, interval, fromDate, toDate, false,false);&#10;&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package historical;&#10;&#10;import java.io.IOException;&#10;import java.nio.file.Files;&#10;import java.nio.file.Paths;&#10;import java.net.http.HttpClient;&#10;import java.net.http.HttpRequest;&#10;import java.net.http.HttpResponse;&#10;import java.net.URI;&#10;import java.time.LocalDateTime;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;import com.google.gson.Gson;&#10;import com.google.gson.JsonObject;&#10;import com.google.gson.JsonArray;&#10;import model.CandleData;&#10;&#10;/**&#10; * Fetches historical OHLCV data from Kite API.&#10; */&#10;public class HistoricalDataFetcher {&#10;    private static final String API_BASE_URL = &quot;https://api.kite.trade&quot;;&#10;    private static final String API_KEY = &quot;kbn0ca43nbzamzga&quot;; // Replace with your actual API key&#10;    private String accessToken;&#10;&#10;    /**&#10;     * Loads access token from JSON file.&#10;     * @throws IOException if file read fails&#10;     */&#10;    public void loadAccessToken() throws IOException {&#10;        String jsonContent = Files.readString(Paths.get(&quot;login/access_token.json&quot;));&#10;        Gson gson = new Gson();&#10;        JsonObject jsonObject = gson.fromJson(jsonContent, JsonObject.class);&#10;        this.accessToken = jsonObject.get(&quot;access_token&quot;).getAsString();&#10;    }&#10;&#10;    /**&#10;     * Fetches historical data for an instrument.&#10;     * @param instrumentToken Instrument token&#10;     * @param interval Data interval (e.g., day, minute)&#10;     * @param fromDate Start date/time&#10;     * @param toDate End date/time&#10;     * @param includeContinuous Whether to include continuous data&#10;     * @param includeOI Whether to include open interest&#10;     * @return List of CandleData&#10;     * @throws IOException, InterruptedException on API failure&#10;     */&#10;    public List&lt;CandleData&gt; fetchHistoricalData(String instrumentToken, String interval,&#10;                                                LocalDateTime fromDate, LocalDateTime toDate,&#10;                                                boolean includeContinuous, boolean includeOI) throws IOException, InterruptedException {&#10;&#10;        // Load access token&#10;        loadAccessToken();&#10;&#10;        // Format dates&#10;        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);&#10;        String fromDateStr = fromDate.format(formatter);&#10;        String toDateStr = toDate.format(formatter);&#10;&#10;        // Build URL&#10;        StringBuilder urlBuilder = new StringBuilder();&#10;        urlBuilder.append(API_BASE_URL)&#10;                .append(&quot;/instruments/historical/&quot;)&#10;                .append(instrumentToken)&#10;                .append(&quot;/&quot;)&#10;                .append(interval)&#10;                .append(&quot;?from=&quot;).append(fromDateStr.replace(&quot; &quot;, &quot;+&quot;))&#10;                .append(&quot;&amp;to=&quot;).append(toDateStr.replace(&quot; &quot;, &quot;+&quot;));&#10;&#10;        if (includeContinuous) {&#10;            urlBuilder.append(&quot;&amp;continuous=1&quot;);&#10;        }&#10;&#10;        if (includeOI) {&#10;            urlBuilder.append(&quot;&amp;oi=1&quot;);&#10;        }&#10;&#10;        // Create HTTP client and request&#10;        HttpClient client = HttpClient.newHttpClient();&#10;        HttpRequest request = HttpRequest.newBuilder()&#10;                .uri(URI.create(urlBuilder.toString()))&#10;                .header(&quot;X-Kite-Version&quot;, &quot;3&quot;)&#10;                .header(&quot;Authorization&quot;, &quot;token &quot; + API_KEY + &quot;:&quot; + accessToken)&#10;                .GET()&#10;                .build();&#10;&#10;        // Send request and get response&#10;        HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString());&#10;&#10;        // Parse and display response&#10;        List&lt;CandleData&gt; candleDataList = null;&#10;        if (response.statusCode() == 200) {&#10;            Gson gson = new Gson();&#10;            JsonObject responseJson = gson.fromJson(response.body(), JsonObject.class);&#10;&#10;            if (responseJson.get(&quot;status&quot;).getAsString().equals(&quot;success&quot;)) {&#10;                JsonObject data = responseJson.getAsJsonObject(&quot;data&quot;);&#10;                JsonArray candles = data.getAsJsonArray(&quot;candles&quot;);&#10;&#10;                System.out.println(&quot;Historical Data for Instrument Token: &quot; + instrumentToken);&#10;                System.out.println(&quot;Interval: &quot; + interval);&#10;                System.out.println(&quot;From: &quot; + fromDateStr + &quot; To: &quot; + toDateStr);&#10;                System.out.println(&quot;Total Records: &quot; + candles.size());&#10;                System.out.println();&#10;&#10;                // Print headers&#10;                if (includeOI) {&#10;                    System.out.println(&quot;Timestamp\t\tOpen\tHigh\tLow\tClose\tVolume\tOI&quot;);&#10;                } else {&#10;                    System.out.println(&quot;Timestamp\t\tOpen\tHigh\tLow\tClose\tVolume&quot;);&#10;                }&#10;                System.out.println(&quot;**********************************************************************************************************&quot;);&#10;&#10;                candleDataList = new ArrayList&lt;&gt;();&#10;                // Print candle data&#10;                for (int i = 0; i &lt; candles.size(); i++) {&#10;                    JsonArray candle = candles.get(i).getAsJsonArray();&#10;&#10;                    long timestamp = candle.get(0).getAsLong();&#10;                    double open = candle.get(1).getAsDouble();&#10;&#10;                    double high = candle.get(2).getAsDouble();&#10;                    double low = candle.get(3).getAsDouble();&#10;                    double close = candle.get(4).getAsDouble();&#10;                    long volume = candle.get(5).getAsLong();&#10;&#10;                    CandleData candleData;// = new CandleData(open,high,low,close,volume,timestamp);&#10;&#10;                    if (includeOI &amp;&amp; candle.size() &gt; 6) {&#10;                        long oi = candle.get(6).getAsLong();&#10;                        System.out.printf(&quot;%s\t%.2f\t%.2f\t%.2f\t%.2f\t%d\t%d%n&quot;,&#10;                                timestamp, open, high, low, close, volume, oi);&#10;&#10;                        candleData = new CandleData(open, high, low, close, volume, oi, timestamp);&#10;                    } else {&#10;                        System.out.printf(&quot;%s\t%.2f\t%.2f\t%.2f\t%.2f\t%d%n&quot;,&#10;                                timestamp, open, high, low, close, volume);&#10;                        candleData = new CandleData(open, high, low, close, volume, 0L, timestamp);&#10;                    }&#10;&#10;                    candleDataList.add(candleData);&#10;                }&#10;            } else {&#10;                System.err.println(&quot;API Error: &quot; + responseJson.get(&quot;message&quot;).getAsString());&#10;            }&#10;        } else {&#10;            System.err.println(&quot;HTTP Error: &quot; + response.statusCode());&#10;            System.err.println(&quot;Response: &quot; + response.body());&#10;        }&#10;        return candleDataList;&#10;&#10;    }&#10;&#10;    // Main method with example usage&#10;    public static void main(String[] args) {&#10;        HistoricalDataFetcher fetcher = new HistoricalDataFetcher();&#10;&#10;        try {&#10;            // Example: Fetch minute data for a NIFTY futures contract&#10;            String instrumentToken = &quot;12517890&quot;; // Replace with actual instrument token&#10;            String interval = &quot;5minute&quot;; // minute, 3minute, 5minute, 10minute, 15minute, 30minute, 60minute, day&#10;&#10;            LocalDateTime fromDate = LocalDateTime.of(2025, 8, 20, 9, 15, 0);&#10;            LocalDateTime toDate = LocalDateTime.of(2025, 9, 11, 15, 30, 0);&#10;&#10;            // Fetch data with OI (for futures/options)&#10;            fetcher.fetchHistoricalData(instrumentToken, interval, fromDate, toDate, false,false);&#10;&#10;        } catch (Exception e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/trading/bot/CPRTradingBot.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/trading/bot/CPRTradingBot.java" />
              <option name="originalContent" value="package trading.bot;&#10;&#10;import java.nio.file.Files;&#10;import java.nio.file.Paths;&#10;import java.time.LocalDate;&#10;import java.time.LocalDateTime;&#10;import java.util.*;&#10;import java.util.concurrent.*;&#10;import java.util.logging.Logger;&#10;&#10;import com.google.gson.Gson;&#10;import com.google.gson.JsonObject;&#10;import historical.HistoricalDataFetcher;&#10;import login.ZerodhaAutoLogin;&#10;import model.CandleData;&#10;&#10;public class CPRTradingBot {&#10;    private static final Logger logger = Logger.getLogger(CPRTradingBot.class.getName());&#10;    &#10;    // Core components&#10;    private final HistoricalDataFetcher historicalFetcher;&#10;    private final CPRCalculator cprCalculator;&#10;    private final InstrumentManager instrumentManager;&#10;    private final PositionManager positionManager;&#10;    &#10;    // Configuration&#10;    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(4);&#10;    private final Map&lt;String, CPRLevels&gt; dailyCPRCache = new ConcurrentHashMap&lt;&gt;();&#10;    private volatile boolean isRunning = false;&#10;    private volatile boolean isLoggedIn = false;&#10;    &#10;    // Trading parameters&#10;    private static final double INITIAL_CAPITAL = 500000; // 5 lakhs&#10;    private static final double MAX_DAILY_LOSS_PERCENT = 2.0; // 2% max daily loss&#10;    private static final double RISK_PER_TRADE_PERCENT = 1.0; // 1% risk per trade&#10;    &#10;    public CPRTradingBot(HistoricalDataFetcher historicalFetcher) {&#10;        this.historicalFetcher = historicalFetcher;&#10;        this.cprCalculator = new CPRCalculator();&#10;        this.instrumentManager = new InstrumentManager();&#10;        &#10;        // Initialize risk parameters&#10;        PositionManager.RiskParameters riskParams = new PositionManager.RiskParameters(&#10;            INITIAL_CAPITAL * (MAX_DAILY_LOSS_PERCENT / 100), // Max daily loss&#10;            10.0, // Max position size as % of capital&#10;            RISK_PER_TRADE_PERCENT, // Risk per trade&#10;            5, // Max positions&#10;            80.0 // Max portfolio exposure %&#10;        );&#10;        &#10;        this.positionManager = new PositionManager(INITIAL_CAPITAL, riskParams);&#10;        &#10;        // Initialize common instruments&#10;        instrumentManager.initializeCommonInstruments();&#10;    }&#10;    &#10;    /**&#10;     * Start the trading bot&#10;     */&#10;    public void startTrading() {&#10;        logger.info(&quot;Starting CPR Trading Bot...&quot;);&#10;        &#10;        try {&#10;            // Step 1: Login and authenticate&#10;            if (!performDailyLogin()) {&#10;                logger.severe(&quot;Failed to login. Cannot start trading.&quot;);&#10;                return;&#10;            }&#10;            &#10;            // Step 2: Subscribe to instruments&#10;            subscribeToInstruments();&#10;            &#10;            // Step 3: Calculate initial CPR levels&#10;            calculateDailyCPRLevels();&#10;            &#10;            // Step 4: Start trading loops&#10;            startTradingLoops();&#10;            &#10;            isRunning = true;&#10;            logger.info(&quot;CPR Trading Bot started successfully!&quot;);&#10;            &#10;        } catch (Exception e) {&#10;            logger.severe(&quot;Error starting trading bot: &quot; + e.getMessage());&#10;            stopTrading();&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Perform daily login and token generation&#10;     */&#10;    private boolean performDailyLogin() {&#10;        try {&#10;            logger.info(&quot;Performing Zerodha login...&quot;);&#10;&#10;            String jsonContent = Files.readString(Paths.get(&quot;login/access_token.json&quot;));&#10;            Gson gson = new Gson();&#10;            JsonObject jsonObject = gson.fromJson(jsonContent, JsonObject.class);&#10;            String accessToken = jsonObject.get(&quot;access_token&quot;).getAsString();&#10;&#10;&#10;            if (accessToken != null &amp;&amp; !accessToken.isEmpty()) {&#10;                isLoggedIn = true;&#10;                logger.info(&quot;Login successful. Access token obtained.&quot;);&#10;&#10;                // Reset daily counters&#10;                positionManager.resetDailyCounters();&#10;                return true;&#10;            }&#10;&#10;&#10;            logger.warning(&quot;Login failed or access token not available.&quot;);&#10;            return false;&#10;&#10;        } catch (Exception e) {&#10;            logger.severe(&quot;Login error: &quot; + e.getMessage());&#10;            return false;&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Subscribe to required instruments for live data&#10;     */&#10;    private void subscribeToInstruments() {&#10;        List&lt;String&gt; watchlist = instrumentManager.getCPRWatchlist();&#10;        &#10;        for (String instrumentToken : watchlist) {&#10;            instrumentManager.subscribeToInstrument(instrumentToken);&#10;        }&#10;        &#10;        logger.info(&quot;Subscribed to &quot; + watchlist.size() + &quot; instruments for live data.&quot;);&#10;    }&#10;    &#10;    /**&#10;     * Calculate CPR levels for all watchlist instruments&#10;     */&#10;    private void calculateDailyCPRLevels() {&#10;        logger.info(&quot;Calculating daily CPR levels...&quot;);&#10;        &#10;        LocalDate today = LocalDate.now();&#10;        LocalDate previousDay = today.minusDays(1);&#10;        &#10;        List&lt;String&gt; watchlist = instrumentManager.getCPRWatchlist();&#10;&#10;        String interval = &quot;day&quot;; // minute, 3minute, 5minute, 10minute, 15minute, 30minute, 60minute, day&#10;&#10;        LocalDateTime fromDate = LocalDateTime.of(2025, 9, 19, 9, 15, 0);&#10;        LocalDateTime toDate = LocalDateTime.of(2025, 9, 19, 15, 30, 0);&#10;&#10;        for (String instrumentToken : watchlist) {&#10;            try {&#10;                // Get historical data for previous day&#10;                List&lt;CandleData&gt; ohlcData = historicalFetcher.fetchHistoricalData(instrumentToken, interval, fromDate, toDate, false,false);&#10;                &#10;                if (ohlcData != null) {&#10;                    double high = ohlcData.get(0).getHigh();&#10;                    double low = ohlcData.get(0).getLow();&#10;                    double close = ohlcData.get(0).getClose();&#10;                    &#10;                    CPRLevels cprLevels = cprCalculator.calculateCPR(high, low, close);&#10;                    dailyCPRCache.put(instrumentToken, cprLevels);&#10;                    &#10;                    logger.info(&quot;CPR calculated for &quot; + instrumentToken + &quot;: &quot; + cprLevels);&#10;                }&#10;                &#10;            } catch (Exception e) {&#10;                logger.warning(&quot;Failed to calculate CPR for &quot; + instrumentToken + &quot;: &quot; + e.getMessage());&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Start main trading loops&#10;     */&#10;    private void startTradingLoops() {&#10;        // Main trading loop - runs every 10 seconds&#10;        scheduler.scheduleWithFixedDelay(this::mainTradingLoop, 0, 10, TimeUnit.SECONDS);&#10;        &#10;        // Position monitoring loop - runs every 5 seconds&#10;        scheduler.scheduleWithFixedDelay(this::monitorPositions, 5, 5, TimeUnit.SECONDS);&#10;        &#10;        // Market status check - runs every minute&#10;        scheduler.scheduleWithFixedDelay(this::checkMarketStatus, 0, 60, TimeUnit.SECONDS);&#10;        &#10;        // Daily reset - runs at market open&#10;        scheduler.scheduleWithFixedDelay(this::performDailyReset, 0, 24, TimeUnit.HOURS);&#10;    }&#10;    &#10;    /**&#10;     * Main trading logic loop&#10;     */&#10;    private void mainTradingLoop() {&#10;        if (!isRunning || !isLoggedIn || !instrumentManager.isMarketOpen()) {&#10;            return;&#10;        }&#10;        &#10;        try {&#10;            Map&lt;String, Double&gt; currentPrices = instrumentManager.getCurrentPrices();&#10;            &#10;            for (Map.Entry&lt;String, Double&gt; entry : currentPrices.entrySet()) {&#10;                String instrumentToken = entry.getKey();&#10;                double currentPrice = entry.getValue();&#10;                &#10;                // Generate trading signals&#10;                List&lt;TradingSignal&gt; signals = generateTradingSignals(instrumentToken, currentPrice);&#10;                &#10;                // Execute valid signals&#10;                for (TradingSignal signal : signals) {&#10;                    if (signal.shouldExecute()) {&#10;                        executeSignal(signal);&#10;                    }&#10;                }&#10;            }&#10;            &#10;        } catch (Exception e) {&#10;            logger.warning(&quot;Error in main trading loop: &quot; + e.getMessage());&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Generate trading signals based on CPR logic&#10;     */&#10;    private List&lt;TradingSignal&gt; generateTradingSignals(String instrumentToken, double currentPrice) {&#10;        List&lt;TradingSignal&gt; signals = new ArrayList&lt;&gt;();&#10;        &#10;        CPRLevels cprLevels = dailyCPRCache.get(instrumentToken);&#10;        if (cprLevels == null) return signals;&#10;        &#10;        // Check if position already exists&#10;        if (positionManager.getOpenPositions().containsKey(instrumentToken)) {&#10;            return signals; // Already have position&#10;        }&#10;        &#10;        // CPR Trading Strategy Logic&#10;        &#10;        // 1. Price above CPR - Bullish signal&#10;        if (cprLevels.isPriceAboveCPR(currentPrice)) {&#10;            double stopLoss = cprLevels.getBottomCentral();&#10;            double target = cprLevels.getR1();&#10;            &#10;            // Ensure good risk-reward ratio (minimum 1:1.5)&#10;            double riskReward = Math.abs(target - currentPrice) / Math.abs(currentPrice - stopLoss);&#10;            &#10;            if (riskReward &gt;= 1.5) {&#10;                int quantity = positionManager.calculatePositionSize(currentPrice, stopLoss, instrumentToken);&#10;                quantity = instrumentManager.calculateLotAdjustedQuantity(instrumentToken, quantity);&#10;                &#10;                TradingSignal signal = new TradingSignal.Builder(instrumentToken, TradingSignal.SignalType.BUY)&#10;                    .triggerPrice(currentPrice)&#10;                    .targetPrice(target)&#10;                    .stopLossPrice(stopLoss)&#10;                    .quantity(quantity)&#10;                    .strength(getSignalStrength(cprLevels, currentPrice))&#10;                    .reason(TradingSignal.TriggerReason.PRICE_ABOVE_CPR)&#10;                    .confidence(calculateConfidence(cprLevels, currentPrice, true))&#10;                    .build();&#10;                &#10;                signals.add(signal);&#10;            }&#10;        }&#10;        &#10;        // 2. Price below CPR - Bearish signal&#10;        else if (cprLevels.isPriceBelowCPR(currentPrice)) {&#10;            double stopLoss = cprLevels.getTopCentral();&#10;            double target = cprLevels.getS1();&#10;            &#10;            double riskReward = Math.abs(currentPrice - target) / Math.abs(stopLoss - currentPrice);&#10;            &#10;            if (riskReward &gt;= 1.5) {&#10;                int quantity = positionManager.calculatePositionSize(currentPrice, stopLoss, instrumentToken);&#10;                quantity = instrumentManager.calculateLotAdjustedQuantity(instrumentToken, quantity);&#10;                &#10;                TradingSignal signal = new TradingSignal.Builder(instrumentToken, TradingSignal.SignalType.SELL)&#10;                    .triggerPrice(currentPrice)&#10;                    .targetPrice(target)&#10;                    .stopLossPrice(stopLoss)&#10;                    .quantity(quantity)&#10;                    .strength(getSignalStrength(cprLevels, currentPrice))&#10;                    .reason(TradingSignal.TriggerReason.PRICE_BELOW_CPR)&#10;                    .confidence(calculateConfidence(cprLevels, currentPrice, false))&#10;                    .build();&#10;                &#10;                signals.add(signal);&#10;            }&#10;        }&#10;        &#10;        return signals;&#10;    }&#10;    &#10;    /**&#10;     * Calculate signal strength based on CPR characteristics&#10;     */&#10;    private TradingSignal.SignalStrength getSignalStrength(CPRLevels cprLevels, double currentPrice) {&#10;        if (cprLevels.getCprType() == CPRLevels.CPRType.NARROW_CPR) {&#10;            return TradingSignal.SignalStrength.STRONG; // Narrow CPR indicates strong breakout potential&#10;        } else if (cprLevels.getCprType() == CPRLevels.CPRType.WIDE_CPR) {&#10;            return TradingSignal.SignalStrength.WEAK; // Wide CPR indicates sideways movement&#10;        } else {&#10;            return TradingSignal.SignalStrength.MODERATE;&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Calculate signal confidence&#10;     */&#10;    private double calculateConfidence(CPRLevels cprLevels, double currentPrice, boolean isBullish) {&#10;        double confidence = 0.5; // Base confidence&#10;        &#10;        // Higher confidence for narrow CPR&#10;        if (cprLevels.getCprType() == CPRLevels.CPRType.NARROW_CPR) {&#10;            confidence += 0.2;&#10;        }&#10;        &#10;        // Higher confidence when price is significantly away from CPR&#10;        double distanceFromCPR;&#10;        if (isBullish) {&#10;            distanceFromCPR = (currentPrice - cprLevels.getTopCentral()) / cprLevels.getTopCentral();&#10;        } else {&#10;            distanceFromCPR = (cprLevels.getBottomCentral() - currentPrice) / cprLevels.getBottomCentral();&#10;        }&#10;        &#10;        if (distanceFromCPR &gt; 0.005) { // More than 0.5% away&#10;            confidence += 0.15;&#10;        }&#10;        &#10;        return Math.min(1.0, confidence);&#10;    }&#10;    &#10;    /**&#10;     * Execute trading signal&#10;     */&#10;    private void executeSignal(TradingSignal signal) {&#10;        try {&#10;            if (positionManager.openPosition(signal)) {&#10;                // Place actual order through Zerodha API&#10;                boolean orderSuccess = placeOrder(signal);&#10;                &#10;                if (orderSuccess) {&#10;                    logger.info(&quot;Order executed successfully: &quot; + signal);&#10;                } else {&#10;                    logger.warning(&quot;Failed to place order: &quot; + signal);&#10;                }&#10;            } else {&#10;                logger.info(&quot;Position rejected by risk management: &quot; + signal.getInstrumentToken());&#10;            }&#10;            &#10;        } catch (Exception e) {&#10;            logger.severe(&quot;Error executing signal: &quot; + e.getMessage());&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Place order through Zerodha API&#10;     */&#10;    private boolean placeOrder(TradingSignal signal) {&#10;        try {&#10;            // This would integrate with your login.ZerodhaAutoLogin class&#10;            Map&lt;String, Object&gt; orderParams = new HashMap&lt;&gt;();&#10;            orderParams.put(&quot;tradingsymbol&quot;, instrumentManager.getInstrumentByToken(signal.getInstrumentToken()).getTradingSymbol());&#10;            orderParams.put(&quot;exchange&quot;, &quot;NSE&quot;);&#10;            orderParams.put(&quot;transaction_type&quot;, signal.getType() == TradingSignal.SignalType.BUY ? &quot;BUY&quot; : &quot;SELL&quot;);&#10;            orderParams.put(&quot;quantity&quot;, signal.getQuantity());&#10;            orderParams.put(&quot;price&quot;, signal.getTriggerPrice());&#10;            orderParams.put(&quot;product&quot;, &quot;MIS&quot;); // Intraday&#10;            orderParams.put(&quot;order_type&quot;, &quot;LIMIT&quot;);&#10;            &#10;        } catch (Exception e) {&#10;            logger.severe(&quot;Order placement error: &quot; + e.getMessage());&#10;            return false;&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Monitor open positions for exits&#10;     */&#10;    private void monitorPositions() {&#10;        if (!isRunning || !isLoggedIn) return;&#10;        &#10;        try {&#10;            Map&lt;String, Double&gt; currentPrices = instrumentManager.getCurrentPrices();&#10;            List&lt;PositionManager.Position&gt; positionsToClose = positionManager.updatePositions(currentPrices);&#10;            &#10;            for (PositionManager.Position position : positionsToClose) {&#10;                String reason = position.shouldCloseOnTarget() ? &quot;Target Hit&quot; : &quot;Stop Loss Hit&quot;;&#10;                positionManager.closePosition(position.getInstrumentToken(), position.getCurrentPrice(), reason);&#10;                &#10;                // Place exit order&#10;                closePosition(position, reason);&#10;            }&#10;            &#10;        } catch (Exception e) {&#10;            logger.warning(&quot;Error monitoring positions: &quot; + e.getMessage());&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Close position through API&#10;     */&#10;    private void closePosition(PositionManager.Position position, String reason) {&#10;        try {&#10;            Map&lt;String, Object&gt; orderParams = new HashMap&lt;&gt;();&#10;            orderParams.put(&quot;tradingsymbol&quot;, instrumentManager.getInstrumentByToken(position.getInstrumentToken()).getTradingSymbol());&#10;            orderParams.put(&quot;exchange&quot;, &quot;NSE&quot;);&#10;            orderParams.put(&quot;transaction_type&quot;, position.getTransactionType().equals(&quot;BUY&quot;) ? &quot;SELL&quot; : &quot;BUY&quot;);&#10;            orderParams.put(&quot;quantity&quot;, position.getQuantity());&#10;            orderParams.put(&quot;product&quot;, &quot;MIS&quot;);&#10;            orderParams.put(&quot;order_type&quot;, &quot;MARKET&quot;);&#10;            &#10;            boolean orderSuccess = zerodhaLogin.placeOrder(orderParams);&#10;            logger.info(String.format(&quot;Position closed: %s, Reason: %s, Success: %s&quot;, &#10;                       position.getInstrumentToken(), reason, orderSuccess));&#10;            &#10;        } catch (Exception e) {&#10;            logger.severe(&quot;Error closing position: &quot; + e.getMessage());&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Check market status and handle market close&#10;     */&#10;    private void checkMarketStatus() {&#10;        if (!instrumentManager.isMarketOpen() &amp;&amp; isRunning) {&#10;            logger.info(&quot;Market closed. Closing all positions...&quot;);&#10;            closeAllPositions(&quot;Market Close&quot;);&#10;        }&#10;        &#10;        // Print daily statistics&#10;        if (isRunning) {&#10;            printDailyStats();&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Close all open positions&#10;     */&#10;    private void closeAllPositions(String reason) {&#10;        Map&lt;String, PositionManager.Position&gt; openPositions = positionManager.getOpenPositions();&#10;        &#10;        for (PositionManager.Position position : openPositions.values()) {&#10;            closePosition(position, reason);&#10;            positionManager.closePosition(position.getInstrumentToken(), position.getCurrentPrice(), reason);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Print daily trading statistics&#10;     */&#10;    private void printDailyStats() {&#10;        Map&lt;String, Object&gt; stats = positionManager.getDailyStats();&#10;        Map&lt;String, Object&gt; marketStatus = instrumentManager.getMarketStatus();&#10;        &#10;        logger.info(&quot;=== Daily Trading Stats ===&quot;);&#10;        logger.info(&quot;Total Capital: &quot; + stats.get(&quot;totalCapital&quot;));&#10;        logger.info(&quot;Daily PnL: &quot; + stats.get(&quot;dailyPnL&quot;));&#10;        logger.info(&quot;Open Positions: &quot; + stats.get(&quot;openPositions&quot;));&#10;        logger.info(&quot;Unrealized PnL: &quot; + stats.get(&quot;totalUnrealizedPnL&quot;));&#10;        logger.info(&quot;Portfolio Exposure: &quot; + stats.get(&quot;portfolioExposure&quot;));&#10;        logger.info(&quot;Market Open: &quot; + marketStatus.get(&quot;isMarketOpen&quot;));&#10;        logger.info(&quot;==========================&quot;);&#10;    }&#10;    &#10;    /**&#10;     * Perform daily reset at market open&#10;     */&#10;    private void performDailyReset() {&#10;        if (instrumentManager.isMarketOpen()) {&#10;            logger.info(&quot;Performing daily reset...&quot;);&#10;            &#10;            // Recalculate CPR levels&#10;            calculateDailyCPRLevels();&#10;            &#10;            // Reset position manager counters&#10;            positionManager.resetDailyCounters();&#10;            &#10;            logger.info(&quot;Daily reset completed.&quot;);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Stop trading bot&#10;     */&#10;    public void stopTrading() {&#10;        logger.info(&quot;Stopping CPR Trading Bot...&quot;);&#10;        &#10;        isRunning = false;&#10;        &#10;        // Close all open positions&#10;        closeAllPositions(&quot;Bot Shutdown&quot;);&#10;        &#10;        // Shutdown scheduler&#10;        scheduler.shutdown();&#10;        try {&#10;            if (!scheduler.awaitTermination(60, TimeUnit.SECONDS)) {&#10;                scheduler.shutdownNow();&#10;            }&#10;        } catch (InterruptedException e) {&#10;            scheduler.shutdownNow();&#10;            Thread.currentThread().interrupt();&#10;        }&#10;        &#10;        logger.info(&quot;CPR Trading Bot stopped.&quot;);&#10;    }&#10;    &#10;    // Main method to run the bot&#10;    public static void main(String[] args) {&#10;        try {&#10;            // Initialize components&#10;            HistoricalDataFetcher historicalFetcher = new HistoricalDataFetcher();&#10;            &#10;            // Create and start bot&#10;            CPRTradingBot bot = new CPRTradingBot(historicalFetcher);&#10;            &#10;            // Add shutdown hook&#10;            Runtime.getRuntime().addShutdownHook(new Thread(bot::stopTrading));&#10;            &#10;            // Start trading&#10;            bot.startTrading();&#10;            &#10;            // Keep main thread alive&#10;            while (bot.isRunning) {&#10;                Thread.sleep(10000); // Check every 10 seconds&#10;            }&#10;            &#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Fatal error: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;    &#10;    // Getter for status check&#10;    public boolean isRunning() {&#10;        return isRunning;&#10;    }&#10;    &#10;    public Map&lt;String, Object&gt; getSystemStatus() {&#10;        Map&lt;String, Object&gt; status = new HashMap&lt;&gt;();&#10;        status.put(&quot;isRunning&quot;, isRunning);&#10;        status.put(&quot;isLoggedIn&quot;, isLoggedIn);&#10;        status.put(&quot;dailyStats&quot;, positionManager.getDailyStats());&#10;        status.put(&quot;marketStatus&quot;, instrumentManager.getMarketStatus());&#10;        return status;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package trading.bot;&#10;&#10;import java.nio.file.Files;&#10;import java.nio.file.Paths;&#10;import java.time.LocalDate;&#10;import java.time.LocalDateTime;&#10;import java.util.*;&#10;import java.util.concurrent.*;&#10;import java.util.logging.Logger;&#10;&#10;import com.google.gson.Gson;&#10;import com.google.gson.JsonObject;&#10;import historical.HistoricalDataFetcher;&#10;import login.ZerodhaAutoLogin;&#10;import model.CandleData;&#10;&#10;/**&#10; * Main trading bot for CPR-based strategies.&#10; */&#10;public class CPRTradingBot {&#10;    private static final Logger logger = Logger.getLogger(CPRTradingBot.class.getName());&#10;&#10;    // Core components&#10;    private final HistoricalDataFetcher historicalFetcher;&#10;    private final CPRCalculator cprCalculator;&#10;    private final InstrumentManager instrumentManager;&#10;    private final PositionManager positionManager;&#10;&#10;    // Configuration&#10;    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(4);&#10;    private final Map&lt;String, CPRLevels&gt; dailyCPRCache = new ConcurrentHashMap&lt;&gt;();&#10;    private volatile boolean isRunning = false;&#10;    private volatile boolean isLoggedIn = false;&#10;&#10;    // Trading parameters&#10;    private static final double INITIAL_CAPITAL = 500000; // 5 lakhs&#10;    private static final double MAX_DAILY_LOSS_PERCENT = 2.0; // 2% max daily loss&#10;    private static final double RISK_PER_TRADE_PERCENT = 1.0; // 1% risk per trade&#10;&#10;    /**&#10;     * Constructs a CPRTradingBot with required dependencies.&#10;     */&#10;    public CPRTradingBot(HistoricalDataFetcher historicalFetcher) {&#10;        this.historicalFetcher = historicalFetcher;&#10;        this.cprCalculator = new CPRCalculator();&#10;        this.instrumentManager = new InstrumentManager();&#10;        &#10;        // Initialize risk parameters&#10;        PositionManager.RiskParameters riskParams = new PositionManager.RiskParameters(&#10;            INITIAL_CAPITAL * (MAX_DAILY_LOSS_PERCENT / 100), // Max daily loss&#10;            10.0, // Max position size as % of capital&#10;            RISK_PER_TRADE_PERCENT, // Risk per trade&#10;            5, // Max positions&#10;            80.0 // Max portfolio exposure %&#10;        );&#10;        &#10;        this.positionManager = new PositionManager(INITIAL_CAPITAL, riskParams);&#10;        &#10;        // Initialize common instruments&#10;        instrumentManager.initializeCommonInstruments();&#10;    }&#10;    &#10;    /**&#10;     * Start the trading bot&#10;     */&#10;    public void startTrading() {&#10;        logger.info(&quot;Starting CPR Trading Bot...&quot;);&#10;        &#10;        try {&#10;            // Step 1: Login and authenticate&#10;            if (!performDailyLogin()) {&#10;                logger.severe(&quot;Failed to login. Cannot start trading.&quot;);&#10;                return;&#10;            }&#10;            &#10;            // Step 2: Subscribe to instruments&#10;            subscribeToInstruments();&#10;            &#10;            // Step 3: Calculate initial CPR levels&#10;            calculateDailyCPRLevels();&#10;            &#10;            // Step 4: Start trading loops&#10;            startTradingLoops();&#10;            &#10;            isRunning = true;&#10;            logger.info(&quot;CPR Trading Bot started successfully!&quot;);&#10;            &#10;        } catch (Exception e) {&#10;            logger.severe(&quot;Error starting trading bot: &quot; + e.getMessage());&#10;            stopTrading();&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Perform daily login and token generation&#10;     */&#10;    private boolean performDailyLogin() {&#10;        try {&#10;            logger.info(&quot;Performing Zerodha login...&quot;);&#10;&#10;            String jsonContent = Files.readString(Paths.get(&quot;login/access_token.json&quot;));&#10;            Gson gson = new Gson();&#10;            JsonObject jsonObject = gson.fromJson(jsonContent, JsonObject.class);&#10;            String accessToken = jsonObject.get(&quot;access_token&quot;).getAsString();&#10;&#10;&#10;            if (accessToken != null &amp;&amp; !accessToken.isEmpty()) {&#10;                isLoggedIn = true;&#10;                logger.info(&quot;Login successful. Access token obtained.&quot;);&#10;&#10;                // Reset daily counters&#10;                positionManager.resetDailyCounters();&#10;                return true;&#10;            }&#10;&#10;&#10;            logger.warning(&quot;Login failed or access token not available.&quot;);&#10;            return false;&#10;&#10;        } catch (Exception e) {&#10;            logger.severe(&quot;Login error: &quot; + e.getMessage());&#10;            return false;&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Subscribe to required instruments for live data&#10;     */&#10;    private void subscribeToInstruments() {&#10;        List&lt;String&gt; watchlist = instrumentManager.getCPRWatchlist();&#10;        &#10;        for (String instrumentToken : watchlist) {&#10;            instrumentManager.subscribeToInstrument(instrumentToken);&#10;        }&#10;        &#10;        logger.info(&quot;Subscribed to &quot; + watchlist.size() + &quot; instruments for live data.&quot;);&#10;    }&#10;    &#10;    /**&#10;     * Calculate CPR levels for all watchlist instruments&#10;     */&#10;    private void calculateDailyCPRLevels() {&#10;        logger.info(&quot;Calculating daily CPR levels...&quot;);&#10;        &#10;        LocalDate today = LocalDate.now();&#10;        LocalDate previousDay = today.minusDays(1);&#10;        &#10;        List&lt;String&gt; watchlist = instrumentManager.getCPRWatchlist();&#10;&#10;        String interval = &quot;day&quot;; // minute, 3minute, 5minute, 10minute, 15minute, 30minute, 60minute, day&#10;&#10;        LocalDateTime fromDate = LocalDateTime.of(2025, 9, 19, 9, 15, 0);&#10;        LocalDateTime toDate = LocalDateTime.of(2025, 9, 19, 15, 30, 0);&#10;&#10;        for (String instrumentToken : watchlist) {&#10;            try {&#10;                // Get historical data for previous day&#10;                List&lt;CandleData&gt; ohlcData = historicalFetcher.fetchHistoricalData(instrumentToken, interval, fromDate, toDate, false,false);&#10;                &#10;                if (ohlcData != null) {&#10;                    double high = ohlcData.get(0).getHigh();&#10;                    double low = ohlcData.get(0).getLow();&#10;                    double close = ohlcData.get(0).getClose();&#10;                    &#10;                    CPRLevels cprLevels = cprCalculator.calculateCPR(high, low, close);&#10;                    dailyCPRCache.put(instrumentToken, cprLevels);&#10;                    &#10;                    logger.info(&quot;CPR calculated for &quot; + instrumentToken + &quot;: &quot; + cprLevels);&#10;                }&#10;                &#10;            } catch (Exception e) {&#10;                logger.warning(&quot;Failed to calculate CPR for &quot; + instrumentToken + &quot;: &quot; + e.getMessage());&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Start main trading loops&#10;     */&#10;    private void startTradingLoops() {&#10;        // Main trading loop - runs every 10 seconds&#10;        scheduler.scheduleWithFixedDelay(this::mainTradingLoop, 0, 10, TimeUnit.SECONDS);&#10;        &#10;        // Position monitoring loop - runs every 5 seconds&#10;        scheduler.scheduleWithFixedDelay(this::monitorPositions, 5, 5, TimeUnit.SECONDS);&#10;        &#10;        // Market status check - runs every minute&#10;        scheduler.scheduleWithFixedDelay(this::checkMarketStatus, 0, 60, TimeUnit.SECONDS);&#10;        &#10;        // Daily reset - runs at market open&#10;        scheduler.scheduleWithFixedDelay(this::performDailyReset, 0, 24, TimeUnit.HOURS);&#10;    }&#10;    &#10;    /**&#10;     * Main trading logic loop&#10;     */&#10;    private void mainTradingLoop() {&#10;        if (!isRunning || !isLoggedIn || !instrumentManager.isMarketOpen()) {&#10;            return;&#10;        }&#10;        &#10;        try {&#10;            Map&lt;String, Double&gt; currentPrices = instrumentManager.getCurrentPrices();&#10;            &#10;            for (Map.Entry&lt;String, Double&gt; entry : currentPrices.entrySet()) {&#10;                String instrumentToken = entry.getKey();&#10;                double currentPrice = entry.getValue();&#10;                &#10;                // Generate trading signals&#10;                List&lt;TradingSignal&gt; signals = generateTradingSignals(instrumentToken, currentPrice);&#10;                &#10;                // Execute valid signals&#10;                for (TradingSignal signal : signals) {&#10;                    if (signal.shouldExecute()) {&#10;                        executeSignal(signal);&#10;                    }&#10;                }&#10;            }&#10;            &#10;        } catch (Exception e) {&#10;            logger.warning(&quot;Error in main trading loop: &quot; + e.getMessage());&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Generate trading signals based on CPR logic&#10;     */&#10;    private List&lt;TradingSignal&gt; generateTradingSignals(String instrumentToken, double currentPrice) {&#10;        List&lt;TradingSignal&gt; signals = new ArrayList&lt;&gt;();&#10;        &#10;        CPRLevels cprLevels = dailyCPRCache.get(instrumentToken);&#10;        if (cprLevels == null) return signals;&#10;        &#10;        // Check if position already exists&#10;        if (positionManager.getOpenPositions().containsKey(instrumentToken)) {&#10;            return signals; // Already have position&#10;        }&#10;        &#10;        // CPR Trading Strategy Logic&#10;        &#10;        // 1. Price above CPR - Bullish signal&#10;        if (cprLevels.isPriceAboveCPR(currentPrice)) {&#10;            double stopLoss = cprLevels.getBottomCentral();&#10;            double target = cprLevels.getR1();&#10;            &#10;            // Ensure good risk-reward ratio (minimum 1:1.5)&#10;            double riskReward = Math.abs(target - currentPrice) / Math.abs(currentPrice - stopLoss);&#10;            &#10;            if (riskReward &gt;= 1.5) {&#10;                int quantity = positionManager.calculatePositionSize(currentPrice, stopLoss, instrumentToken);&#10;                quantity = instrumentManager.calculateLotAdjustedQuantity(instrumentToken, quantity);&#10;                &#10;                TradingSignal signal = new TradingSignal.Builder(instrumentToken, TradingSignal.SignalType.BUY)&#10;                    .triggerPrice(currentPrice)&#10;                    .targetPrice(target)&#10;                    .stopLossPrice(stopLoss)&#10;                    .quantity(quantity)&#10;                    .strength(getSignalStrength(cprLevels, currentPrice))&#10;                    .reason(TradingSignal.TriggerReason.PRICE_ABOVE_CPR)&#10;                    .confidence(calculateConfidence(cprLevels, currentPrice, true))&#10;                    .build();&#10;                &#10;                signals.add(signal);&#10;            }&#10;        }&#10;        &#10;        // 2. Price below CPR - Bearish signal&#10;        else if (cprLevels.isPriceBelowCPR(currentPrice)) {&#10;            double stopLoss = cprLevels.getTopCentral();&#10;            double target = cprLevels.getS1();&#10;            &#10;            double riskReward = Math.abs(currentPrice - target) / Math.abs(stopLoss - currentPrice);&#10;            &#10;            if (riskReward &gt;= 1.5) {&#10;                int quantity = positionManager.calculatePositionSize(currentPrice, stopLoss, instrumentToken);&#10;                quantity = instrumentManager.calculateLotAdjustedQuantity(instrumentToken, quantity);&#10;                &#10;                TradingSignal signal = new TradingSignal.Builder(instrumentToken, TradingSignal.SignalType.SELL)&#10;                    .triggerPrice(currentPrice)&#10;                    .targetPrice(target)&#10;                    .stopLossPrice(stopLoss)&#10;                    .quantity(quantity)&#10;                    .strength(getSignalStrength(cprLevels, currentPrice))&#10;                    .reason(TradingSignal.TriggerReason.PRICE_BELOW_CPR)&#10;                    .confidence(calculateConfidence(cprLevels, currentPrice, false))&#10;                    .build();&#10;                &#10;                signals.add(signal);&#10;            }&#10;        }&#10;        &#10;        return signals;&#10;    }&#10;    &#10;    /**&#10;     * Calculate signal strength based on CPR characteristics&#10;     */&#10;    private TradingSignal.SignalStrength getSignalStrength(CPRLevels cprLevels, double currentPrice) {&#10;        if (cprLevels.getCprType() == CPRLevels.CPRType.NARROW_CPR) {&#10;            return TradingSignal.SignalStrength.STRONG; // Narrow CPR indicates strong breakout potential&#10;        } else if (cprLevels.getCprType() == CPRLevels.CPRType.WIDE_CPR) {&#10;            return TradingSignal.SignalStrength.WEAK; // Wide CPR indicates sideways movement&#10;        } else {&#10;            return TradingSignal.SignalStrength.MODERATE;&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Calculate signal confidence&#10;     */&#10;    private double calculateConfidence(CPRLevels cprLevels, double currentPrice, boolean isBullish) {&#10;        double confidence = 0.5; // Base confidence&#10;        &#10;        // Higher confidence for narrow CPR&#10;        if (cprLevels.getCprType() == CPRLevels.CPRType.NARROW_CPR) {&#10;            confidence += 0.2;&#10;        }&#10;        &#10;        // Higher confidence when price is significantly away from CPR&#10;        double distanceFromCPR;&#10;        if (isBullish) {&#10;            distanceFromCPR = (currentPrice - cprLevels.getTopCentral()) / cprLevels.getTopCentral();&#10;        } else {&#10;            distanceFromCPR = (cprLevels.getBottomCentral() - currentPrice) / cprLevels.getBottomCentral();&#10;        }&#10;        &#10;        if (distanceFromCPR &gt; 0.005) { // More than 0.5% away&#10;            confidence += 0.15;&#10;        }&#10;        &#10;        return Math.min(1.0, confidence);&#10;    }&#10;    &#10;    /**&#10;     * Execute trading signal&#10;     */&#10;    private void executeSignal(TradingSignal signal) {&#10;        try {&#10;            if (positionManager.openPosition(signal)) {&#10;                // Place actual order through Zerodha API&#10;                boolean orderSuccess = placeOrder(signal);&#10;                &#10;                if (orderSuccess) {&#10;                    logger.info(&quot;Order executed successfully: &quot; + signal);&#10;                } else {&#10;                    logger.warning(&quot;Failed to place order: &quot; + signal);&#10;                }&#10;            } else {&#10;                logger.info(&quot;Position rejected by risk management: &quot; + signal.getInstrumentToken());&#10;            }&#10;            &#10;        } catch (Exception e) {&#10;            logger.severe(&quot;Error executing signal: &quot; + e.getMessage());&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Place order through Zerodha API&#10;     */&#10;    private boolean placeOrder(TradingSignal signal) {&#10;        try {&#10;            // This would integrate with your login.ZerodhaAutoLogin class&#10;            Map&lt;String, Object&gt; orderParams = new HashMap&lt;&gt;();&#10;            orderParams.put(&quot;tradingsymbol&quot;, instrumentManager.getInstrumentByToken(signal.getInstrumentToken()).getTradingSymbol());&#10;            orderParams.put(&quot;exchange&quot;, &quot;NSE&quot;);&#10;            orderParams.put(&quot;transaction_type&quot;, signal.getType() == TradingSignal.SignalType.BUY ? &quot;BUY&quot; : &quot;SELL&quot;);&#10;            orderParams.put(&quot;quantity&quot;, signal.getQuantity());&#10;            orderParams.put(&quot;price&quot;, signal.getTriggerPrice());&#10;            orderParams.put(&quot;product&quot;, &quot;MIS&quot;); // Intraday&#10;            orderParams.put(&quot;order_type&quot;, &quot;LIMIT&quot;);&#10;            &#10;        } catch (Exception e) {&#10;            logger.severe(&quot;Order placement error: &quot; + e.getMessage());&#10;            return false;&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Monitor open positions for exits&#10;     */&#10;    private void monitorPositions() {&#10;        if (!isRunning || !isLoggedIn) return;&#10;        &#10;        try {&#10;            Map&lt;String, Double&gt; currentPrices = instrumentManager.getCurrentPrices();&#10;            List&lt;PositionManager.Position&gt; positionsToClose = positionManager.updatePositions(currentPrices);&#10;            &#10;            for (PositionManager.Position position : positionsToClose) {&#10;                String reason = position.shouldCloseOnTarget() ? &quot;Target Hit&quot; : &quot;Stop Loss Hit&quot;;&#10;                positionManager.closePosition(position.getInstrumentToken(), position.getCurrentPrice(), reason);&#10;                &#10;                // Place exit order&#10;                closePosition(position, reason);&#10;            }&#10;            &#10;        } catch (Exception e) {&#10;            logger.warning(&quot;Error monitoring positions: &quot; + e.getMessage());&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Close position through API&#10;     */&#10;    private void closePosition(PositionManager.Position position, String reason) {&#10;        try {&#10;            Map&lt;String, Object&gt; orderParams = new HashMap&lt;&gt;();&#10;            orderParams.put(&quot;tradingsymbol&quot;, instrumentManager.getInstrumentByToken(position.getInstrumentToken()).getTradingSymbol());&#10;            orderParams.put(&quot;exchange&quot;, &quot;NSE&quot;);&#10;            orderParams.put(&quot;transaction_type&quot;, position.getTransactionType().equals(&quot;BUY&quot;) ? &quot;SELL&quot; : &quot;BUY&quot;);&#10;            orderParams.put(&quot;quantity&quot;, position.getQuantity());&#10;            orderParams.put(&quot;product&quot;, &quot;MIS&quot;);&#10;            orderParams.put(&quot;order_type&quot;, &quot;MARKET&quot;);&#10;            &#10;            boolean orderSuccess = zerodhaLogin.placeOrder(orderParams);&#10;            logger.info(String.format(&quot;Position closed: %s, Reason: %s, Success: %s&quot;, &#10;                       position.getInstrumentToken(), reason, orderSuccess));&#10;            &#10;        } catch (Exception e) {&#10;            logger.severe(&quot;Error closing position: &quot; + e.getMessage());&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Check market status and handle market close&#10;     */&#10;    private void checkMarketStatus() {&#10;        if (!instrumentManager.isMarketOpen() &amp;&amp; isRunning) {&#10;            logger.info(&quot;Market closed. Closing all positions...&quot;);&#10;            closeAllPositions(&quot;Market Close&quot;);&#10;        }&#10;        &#10;        // Print daily statistics&#10;        if (isRunning) {&#10;            printDailyStats();&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Close all open positions&#10;     */&#10;    private void closeAllPositions(String reason) {&#10;        Map&lt;String, PositionManager.Position&gt; openPositions = positionManager.getOpenPositions();&#10;        &#10;        for (PositionManager.Position position : openPositions.values()) {&#10;            closePosition(position, reason);&#10;            positionManager.closePosition(position.getInstrumentToken(), position.getCurrentPrice(), reason);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Print daily trading statistics&#10;     */&#10;    private void printDailyStats() {&#10;        Map&lt;String, Object&gt; stats = positionManager.getDailyStats();&#10;        Map&lt;String, Object&gt; marketStatus = instrumentManager.getMarketStatus();&#10;        &#10;        logger.info(&quot;=== Daily Trading Stats ===&quot;);&#10;        logger.info(&quot;Total Capital: &quot; + stats.get(&quot;totalCapital&quot;));&#10;        logger.info(&quot;Daily PnL: &quot; + stats.get(&quot;dailyPnL&quot;));&#10;        logger.info(&quot;Open Positions: &quot; + stats.get(&quot;openPositions&quot;));&#10;        logger.info(&quot;Unrealized PnL: &quot; + stats.get(&quot;totalUnrealizedPnL&quot;));&#10;        logger.info(&quot;Portfolio Exposure: &quot; + stats.get(&quot;portfolioExposure&quot;));&#10;        logger.info(&quot;Market Open: &quot; + marketStatus.get(&quot;isMarketOpen&quot;));&#10;        logger.info(&quot;==========================&quot;);&#10;    }&#10;    &#10;    /**&#10;     * Perform daily reset at market open&#10;     */&#10;    private void performDailyReset() {&#10;        if (instrumentManager.isMarketOpen()) {&#10;            logger.info(&quot;Performing daily reset...&quot;);&#10;            &#10;            // Recalculate CPR levels&#10;            calculateDailyCPRLevels();&#10;            &#10;            // Reset position manager counters&#10;            positionManager.resetDailyCounters();&#10;            &#10;            logger.info(&quot;Daily reset completed.&quot;);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Stop trading bot&#10;     */&#10;    public void stopTrading() {&#10;        logger.info(&quot;Stopping CPR Trading Bot...&quot;);&#10;        &#10;        isRunning = false;&#10;        &#10;        // Close all open positions&#10;        closeAllPositions(&quot;Bot Shutdown&quot;);&#10;        &#10;        // Shutdown scheduler&#10;        scheduler.shutdown();&#10;        try {&#10;            if (!scheduler.awaitTermination(60, TimeUnit.SECONDS)) {&#10;                scheduler.shutdownNow();&#10;            }&#10;        } catch (InterruptedException e) {&#10;            scheduler.shutdownNow();&#10;            Thread.currentThread().interrupt();&#10;        }&#10;        &#10;        logger.info(&quot;CPR Trading Bot stopped.&quot;);&#10;    }&#10;    &#10;    // Main method to run the bot&#10;    public static void main(String[] args) {&#10;        try {&#10;            // Initialize components&#10;            HistoricalDataFetcher historicalFetcher = new HistoricalDataFetcher();&#10;            &#10;            // Create and start bot&#10;            CPRTradingBot bot = new CPRTradingBot(historicalFetcher);&#10;            &#10;            // Add shutdown hook&#10;            Runtime.getRuntime().addShutdownHook(new Thread(bot::stopTrading));&#10;            &#10;            // Start trading&#10;            bot.startTrading();&#10;            &#10;            // Keep main thread alive&#10;            while (bot.isRunning) {&#10;                Thread.sleep(10000); // Check every 10 seconds&#10;            }&#10;            &#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Fatal error: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;    &#10;    // Getter for status check&#10;    public boolean isRunning() {&#10;        return isRunning;&#10;    }&#10;    &#10;    public Map&lt;String, Object&gt; getSystemStatus() {&#10;        Map&lt;String, Object&gt; status = new HashMap&lt;&gt;();&#10;        status.put(&quot;isRunning&quot;, isRunning);&#10;        status.put(&quot;isLoggedIn&quot;, isLoggedIn);&#10;        status.put(&quot;dailyStats&quot;, positionManager.getDailyStats());&#10;        status.put(&quot;marketStatus&quot;, instrumentManager.getMarketStatus());&#10;        return status;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/trading/bot/InstrumentManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/trading/bot/InstrumentManager.java" />
              <option name="originalContent" value="package trading.bot;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;public class InstrumentManager {&#10;    &#10;    public static class Instrument {&#10;        private final String instrumentToken;&#10;        private final String tradingSymbol;&#10;        private final String name;&#10;        private final String exchange;&#10;        private final String segment;&#10;        private final double tickSize;&#10;        private final double lotSize;&#10;        private final boolean isActive;&#10;        &#10;        public Instrument(String instrumentToken, String tradingSymbol, String name,&#10;                         String exchange, String segment, double tickSize, double lotSize) {&#10;            this.instrumentToken = instrumentToken;&#10;            this.tradingSymbol = tradingSymbol;&#10;            this.name = name;&#10;            this.exchange = exchange;&#10;            this.segment = segment;&#10;            this.tickSize = tickSize;&#10;            this.lotSize = lotSize;&#10;            this.isActive = true;&#10;        }&#10;        &#10;        public String getInstrumentToken() { return instrumentToken; }&#10;        public String getTradingSymbol() { return tradingSymbol; }&#10;        public String getName() { return name; }&#10;        public String getExchange() { return exchange; }&#10;        public String getSegment() { return segment; }&#10;        public double getTickSize() { return tickSize; }&#10;        public double getLotSize() { return lotSize; }&#10;        public boolean isActive() { return isActive; }&#10;    }&#10;    &#10;    public static class LiveQuote {&#10;        private final String instrumentToken;&#10;        private final double lastPrice;&#10;        private final double open;&#10;        private final double high;&#10;        private final double low;&#10;        private final double close;&#10;        private final long volume;&#10;        private final double change;&#10;        private final double changePercent;&#10;        private final LocalDateTime timestamp;&#10;        &#10;        public LiveQuote(String instrumentToken, double lastPrice, double open, &#10;                        double high, double low, double close, long volume) {&#10;            this.instrumentToken = instrumentToken;&#10;            this.lastPrice = lastPrice;&#10;            this.open = open;&#10;            this.high = high;&#10;            this.low = low;&#10;            this.close = close;&#10;            this.volume = volume;&#10;            this.change = lastPrice - close;&#10;            this.changePercent = (change / close) * 100;&#10;            this.timestamp = LocalDateTime.now();&#10;        }&#10;        &#10;        public String getInstrumentToken() { return instrumentToken; }&#10;        public double getLastPrice() { return lastPrice; }&#10;        public double getOpen() { return open; }&#10;        public double getHigh() { return high; }&#10;        public double getLow() { return low; }&#10;        public double getClose() { return close; }&#10;        public long getVolume() { return volume; }&#10;        public double getChange() { return change; }&#10;        public double getChangePercent() { return changePercent; }&#10;        public LocalDateTime getTimestamp() { return timestamp; }&#10;    }&#10;    &#10;    private final Map&lt;String, Instrument&gt; instruments = new ConcurrentHashMap&lt;&gt;();&#10;    private final Map&lt;String, String&gt; symbolToToken = new ConcurrentHashMap&lt;&gt;();&#10;    private final Map&lt;String, LiveQuote&gt; liveQuotes = new ConcurrentHashMap&lt;&gt;();&#10;    private final Set&lt;String&gt; subscribedTokens = ConcurrentHashMap.newKeySet();&#10;    &#10;    public void initializeCommonInstruments() {&#10;        addInstrument(&quot;256265&quot;, &quot;NIFTY 50&quot;, &quot;NIFTY 50&quot;, &quot;NSE&quot;, &quot;INDICES&quot;, 0.05, 25);&#10;        addInstrument(&quot;260105&quot;, &quot;NIFTY BANK&quot;, &quot;NIFTY BANK&quot;, &quot;NSE&quot;, &quot;INDICES&quot;, 0.05, 15);&#10;        addInstrument(&quot;8045826&quot;, &quot;NIFTY23SEPFUT&quot;, &quot;NIFTY 50 SEP FUT&quot;, &quot;NFO&quot;, &quot;FUT&quot;, 0.05, 25);&#10;        addInstrument(&quot;8040706&quot;, &quot;BANKNIFTY23SEPFUT&quot;, &quot;BANK NIFTY SEP FUT&quot;, &quot;NFO&quot;, &quot;FUT&quot;, 0.05, 15);&#10;        &#10;        // Initialize with mock live data&#10;        updateLiveQuote(&quot;256265&quot;, 19800, 19750, 19850, 19720, 19780, 1000000);&#10;        updateLiveQuote(&quot;260105&quot;, 44500, 44400, 44600, 44350, 44480, 500000);&#10;        updateLiveQuote(&quot;8045826&quot;, 19850, 19800, 19900, 19770, 19830, 800000);&#10;        updateLiveQuote(&quot;8040706&quot;, 44600, 44550, 44700, 44500, 44580, 400000);&#10;    }&#10;    &#10;    public void addInstrument(String token, String symbol, String name, &#10;                             String exchange, String segment, double tickSize, double lotSize) {&#10;        Instrument instrument = new Instrument(token, symbol, name, exchange, segment, tickSize, lotSize);&#10;        instruments.put(token, instrument);&#10;        symbolToToken.put(symbol.toUpperCase(), token);&#10;    }&#10;    &#10;    public Instrument getInstrumentByToken(String token) {&#10;        return instruments.get(token);&#10;    }&#10;    &#10;    public boolean subscribeToInstrument(String instrumentToken) {&#10;        Instrument instrument = instruments.get(instrumentToken);&#10;        if (instrument != null &amp;&amp; instrument.isActive()) {&#10;            subscribedTokens.add(instrumentToken);&#10;            return true;&#10;        }&#10;        return false;&#10;    }&#10;    &#10;    public void updateLiveQuote(String instrumentToken, double lastPrice, double open,&#10;                               double high, double low, double close, long volume) {&#10;        if (subscribedTokens.contains(instrumentToken) || instruments.containsKey(instrumentToken)) {&#10;            LiveQuote quote = new LiveQuote(instrumentToken, lastPrice, open, high, low, close, volume);&#10;            liveQuotes.put(instrumentToken, quote);&#10;        }&#10;    }&#10;    &#10;    public LiveQuote getLiveQuote(String instrumentToken) {&#10;        return liveQuotes.get(instrumentToken);&#10;    }&#10;    &#10;    public Map&lt;String, Double&gt; getCurrentPrices() {&#10;        Map&lt;String, Double&gt; prices = new HashMap&lt;&gt;();&#10;        for (Map.Entry&lt;String, LiveQuote&gt; entry : liveQuotes.entrySet()) {&#10;            // Simulate live price changes&#10;            double basePrice = entry.getValue().getLastPrice();&#10;            double currentPrice = basePrice + (Math.random() - 0.5) * basePrice * 0.001; // 0.1% variation&#10;            prices.put(entry.getKey(), currentPrice);&#10;        }&#10;        return prices;&#10;    }&#10;    &#10;    public int calculateLotAdjustedQuantity(String instrumentToken, int desiredQuantity) {&#10;        Instrument instrument = instruments.get(instrumentToken);&#10;        if (instrument != null) {&#10;            double lotSize = instrument.getLotSize();&#10;            return (int) (Math.floor(desiredQuantity / lotSize) * lotSize);&#10;        }&#10;        return desiredQuantity;&#10;    }&#10;    &#10;    public List&lt;String&gt; getCPRWatchlist() {&#10;        return Arrays.asList(&quot;256265&quot;, &quot;260105&quot;, &quot;8045826&quot;, &quot;8040706&quot;);&#10;    }&#10;    &#10;    public boolean isMarketOpen() {&#10;        LocalDateTime now = LocalDateTime.now();&#10;        int hour = now.getHour();&#10;        int minute = now.getMinute();&#10;        int dayOfWeek = now.getDayOfWeek().getValue();&#10;        &#10;        boolean isWeekday = dayOfWeek &gt;= 1 &amp;&amp; dayOfWeek &lt;= 5;&#10;        boolean isMarketHours = (hour == 9 &amp;&amp; minute &gt;= 15) || (hour &gt;= 10 &amp;&amp; hour &lt; 15) || (hour == 15 &amp;&amp; minute &lt;= 30);&#10;        &#10;        return isWeekday &amp;&amp; isMarketHours;&#10;    }&#10;    &#10;    public Map&lt;String, Object&gt; getMarketStatus() {&#10;        Map&lt;String, Object&gt; status = new HashMap&lt;&gt;();&#10;        status.put(&quot;isMarketOpen&quot;, isMarketOpen());&#10;        status.put(&quot;subscribedInstruments&quot;, subscribedTokens.size());&#10;        status.put(&quot;liveQuotesAvailable&quot;, liveQuotes.size());&#10;        status.put(&quot;totalInstruments&quot;, instruments.size());&#10;        status.put(&quot;lastUpdateTime&quot;, LocalDateTime.now());&#10;        return status;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package trading.bot;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;/**&#10; * Manages trading instruments and their live quotes.&#10; */&#10;public class InstrumentManager {&#10;    /**&#10;     * Represents a tradable instrument.&#10;     */&#10;    public static class Instrument {&#10;        private final String instrumentToken;&#10;        private final String tradingSymbol;&#10;        private final String name;&#10;        private final String exchange;&#10;        private final String segment;&#10;        private final double tickSize;&#10;        private final double lotSize;&#10;        private final boolean isActive;&#10;&#10;        /**&#10;         * Constructs an Instrument object.&#10;         */&#10;        public Instrument(String instrumentToken, String tradingSymbol, String name,&#10;                         String exchange, String segment, double tickSize, double lotSize) {&#10;            this.instrumentToken = instrumentToken;&#10;            this.tradingSymbol = tradingSymbol;&#10;            this.name = name;&#10;            this.exchange = exchange;&#10;            this.segment = segment;&#10;            this.tickSize = tickSize;&#10;            this.lotSize = lotSize;&#10;            this.isActive = true;&#10;        }&#10;&#10;        // Getters&#10;        public String getInstrumentToken() { return instrumentToken; }&#10;        public String getTradingSymbol() { return tradingSymbol; }&#10;        public String getName() { return name; }&#10;        public String getExchange() { return exchange; }&#10;        public String getSegment() { return segment; }&#10;        public double getTickSize() { return tickSize; }&#10;        public double getLotSize() { return lotSize; }&#10;        public boolean isActive() { return isActive; }&#10;    }&#10;&#10;    /**&#10;     * Represents a live quote for an instrument.&#10;     */&#10;    public static class LiveQuote {&#10;        private final String instrumentToken;&#10;        private final double lastPrice;&#10;        private final double open;&#10;        private final double high;&#10;        private final double low;&#10;        private final double close;&#10;        private final long volume;&#10;        private final double change;&#10;        private final double changePercent;&#10;&#10;        /**&#10;         * Constructs a LiveQuote object.&#10;         */&#10;        public LiveQuote(String instrumentToken, double lastPrice, double open, double high,&#10;                        double low, double close, long volume, double change, double changePercent) {&#10;            this.instrumentToken = instrumentToken;&#10;            this.lastPrice = lastPrice;&#10;            this.open = open;&#10;            this.high = high;&#10;            this.low = low;&#10;            this.close = close;&#10;            this.volume = volume;&#10;            this.change = change;&#10;            this.changePercent = changePercent;&#10;        }&#10;&#10;        // Getters&#10;        public String getInstrumentToken() { return instrumentToken; }&#10;        public double getLastPrice() { return lastPrice; }&#10;        public double getOpen() { return open; }&#10;        public double getHigh() { return high; }&#10;        public double getLow() { return low; }&#10;        public double getClose() { return close; }&#10;        public long getVolume() { return volume; }&#10;        public double getChange() { return change; }&#10;        public double getChangePercent() { return changePercent; }&#10;    }&#10;&#10;    private final Map&lt;String, Instrument&gt; instruments = new ConcurrentHashMap&lt;&gt;();&#10;    private final Map&lt;String, String&gt; symbolToToken = new ConcurrentHashMap&lt;&gt;();&#10;    private final Map&lt;String, LiveQuote&gt; liveQuotes = new ConcurrentHashMap&lt;&gt;();&#10;    private final Set&lt;String&gt; subscribedTokens = ConcurrentHashMap.newKeySet();&#10;&#10;    public void initializeCommonInstruments() {&#10;        addInstrument(&quot;256265&quot;, &quot;NIFTY 50&quot;, &quot;NIFTY 50&quot;, &quot;NSE&quot;, &quot;INDICES&quot;, 0.05, 25);&#10;        addInstrument(&quot;260105&quot;, &quot;NIFTY BANK&quot;, &quot;NIFTY BANK&quot;, &quot;NSE&quot;, &quot;INDICES&quot;, 0.05, 15);&#10;        addInstrument(&quot;8045826&quot;, &quot;NIFTY23SEPFUT&quot;, &quot;NIFTY 50 SEP FUT&quot;, &quot;NFO&quot;, &quot;FUT&quot;, 0.05, 25);&#10;        addInstrument(&quot;8040706&quot;, &quot;BANKNIFTY23SEPFUT&quot;, &quot;BANK NIFTY SEP FUT&quot;, &quot;NFO&quot;, &quot;FUT&quot;, 0.05, 15);&#10;&#10;        // Initialize with mock live data&#10;        updateLiveQuote(&quot;256265&quot;, 19800, 19750, 19850, 19720, 19780, 1000000);&#10;        updateLiveQuote(&quot;260105&quot;, 44500, 44400, 44600, 44350, 44480, 500000);&#10;        updateLiveQuote(&quot;8045826&quot;, 19850, 19800, 19900, 19770, 19830, 800000);&#10;        updateLiveQuote(&quot;8040706&quot;, 44600, 44550, 44700, 44500, 44580, 400000);&#10;    }&#10;&#10;    public void addInstrument(String token, String symbol, String name,&#10;                             String exchange, String segment, double tickSize, double lotSize) {&#10;        Instrument instrument = new Instrument(token, symbol, name, exchange, segment, tickSize, lotSize);&#10;        instruments.put(token, instrument);&#10;        symbolToToken.put(symbol.toUpperCase(), token);&#10;    }&#10;&#10;    public Instrument getInstrumentByToken(String token) {&#10;        return instruments.get(token);&#10;    }&#10;&#10;    public boolean subscribeToInstrument(String instrumentToken) {&#10;        Instrument instrument = instruments.get(instrumentToken);&#10;        if (instrument != null &amp;&amp; instrument.isActive()) {&#10;            subscribedTokens.add(instrumentToken);&#10;            return true;&#10;        }&#10;        return false;&#10;    }&#10;&#10;    public void updateLiveQuote(String instrumentToken, double lastPrice, double open,&#10;                               double high, double low, double close, long volume) {&#10;        if (subscribedTokens.contains(instrumentToken) || instruments.containsKey(instrumentToken)) {&#10;            LiveQuote quote = new LiveQuote(instrumentToken, lastPrice, open, high, low, close, volume, lastPrice - close, ((lastPrice - close) / close) * 100);&#10;            liveQuotes.put(instrumentToken, quote);&#10;        }&#10;    }&#10;&#10;    public LiveQuote getLiveQuote(String instrumentToken) {&#10;        return liveQuotes.get(instrumentToken);&#10;    }&#10;&#10;    public Map&lt;String, Double&gt; getCurrentPrices() {&#10;        Map&lt;String, Double&gt; prices = new HashMap&lt;&gt;();&#10;        for (Map.Entry&lt;String, LiveQuote&gt; entry : liveQuotes.entrySet()) {&#10;            // Simulate live price changes&#10;            double basePrice = entry.getValue().getLastPrice();&#10;            double currentPrice = basePrice + (Math.random() - 0.5) * basePrice * 0.001; // 0.1% variation&#10;            prices.put(entry.getKey(), currentPrice);&#10;        }&#10;        return prices;&#10;    }&#10;&#10;    public int calculateLotAdjustedQuantity(String instrumentToken, int desiredQuantity) {&#10;        Instrument instrument = instruments.get(instrumentToken);&#10;        if (instrument != null) {&#10;            double lotSize = instrument.getLotSize();&#10;            return (int) (Math.floor(desiredQuantity / lotSize) * lotSize);&#10;        }&#10;        return desiredQuantity;&#10;    }&#10;&#10;    public List&lt;String&gt; getCPRWatchlist() {&#10;        return Arrays.asList(&quot;256265&quot;, &quot;260105&quot;, &quot;8045826&quot;, &quot;8040706&quot;);&#10;    }&#10;&#10;    public boolean isMarketOpen() {&#10;        LocalDateTime now = LocalDateTime.now();&#10;        int hour = now.getHour();&#10;        int minute = now.getMinute();&#10;        int dayOfWeek = now.getDayOfWeek().getValue();&#10;&#10;        boolean isWeekday = dayOfWeek &gt;= 1 &amp;&amp; dayOfWeek &lt;= 5;&#10;        boolean isMarketHours = (hour == 9 &amp;&amp; minute &gt;= 15) || (hour &gt;= 10 &amp;&amp; hour &lt; 15) || (hour == 15 &amp;&amp; minute &lt;= 30);&#10;&#10;        return isWeekday &amp;&amp; isMarketHours;&#10;    }&#10;&#10;    public Map&lt;String, Object&gt; getMarketStatus() {&#10;        Map&lt;String, Object&gt; status = new HashMap&lt;&gt;();&#10;        status.put(&quot;isMarketOpen&quot;, isMarketOpen());&#10;        status.put(&quot;subscribedInstruments&quot;, subscribedTokens.size());&#10;        status.put(&quot;liveQuotesAvailable&quot;, liveQuotes.size());&#10;        status.put(&quot;totalInstruments&quot;, instruments.size());&#10;        status.put(&quot;lastUpdateTime&quot;, LocalDateTime.now());&#10;        return status;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/trading/bot/PositionManager.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/trading/bot/PositionManager.java" />
              <option name="originalContent" value="package trading.bot;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.atomic.AtomicDouble;&#10;&#10;public class PositionManager {&#10;    &#10;    public static class Position {&#10;        private final String instrumentToken;&#10;        private final String transactionType;&#10;        private final int quantity;&#10;        private final double entryPrice;&#10;        private final double stopLoss;&#10;        private final double target;&#10;        private final LocalDateTime entryTime;&#10;        private double currentPrice;&#10;        private boolean isOpen = true;&#10;        private double realizedPnL = 0;&#10;        private LocalDateTime exitTime;&#10;        &#10;        public Position(String instrumentToken, String transactionType, int quantity, &#10;                       double entryPrice, double stopLoss, double target) {&#10;            this.instrumentToken = instrumentToken;&#10;            this.transactionType = transactionType;&#10;            this.quantity = quantity;&#10;            this.entryPrice = entryPrice;&#10;            this.stopLoss = stopLoss;&#10;            this.target = target;&#10;            this.entryTime = LocalDateTime.now();&#10;            this.currentPrice = entryPrice;&#10;        }&#10;        &#10;        public void updateCurrentPrice(double price) { this.currentPrice = price; }&#10;        &#10;        public double getUnrealizedPnL() {&#10;            if (!isOpen) return realizedPnL;&#10;            return &quot;BUY&quot;.equals(transactionType) ? &#10;                (currentPrice - entryPrice) * quantity : (entryPrice - currentPrice) * quantity;&#10;        }&#10;        &#10;        public void closePosition(double exitPrice) {&#10;            this.currentPrice = exitPrice;&#10;            this.realizedPnL = getUnrealizedPnL();&#10;            this.isOpen = false;&#10;            this.exitTime = LocalDateTime.now();&#10;        }&#10;        &#10;        public boolean shouldCloseOnStopLoss() {&#10;            return &quot;BUY&quot;.equals(transactionType) ? currentPrice &lt;= stopLoss : currentPrice &gt;= stopLoss;&#10;        }&#10;        &#10;        public boolean shouldCloseOnTarget() {&#10;            return &quot;BUY&quot;.equals(transactionType) ? currentPrice &gt;= target : currentPrice &lt;= target;&#10;        }&#10;        &#10;        // Getters&#10;        public String getInstrumentToken() { return instrumentToken; }&#10;        public String getTransactionType() { return transactionType; }&#10;        public int getQuantity() { return quantity; }&#10;        public double getEntryPrice() { return entryPrice; }&#10;        public double getStopLoss() { return stopLoss; }&#10;        public double getTarget() { return target; }&#10;        public LocalDateTime getEntryTime() { return entryTime; }&#10;        public double getCurrentPrice() { return currentPrice; }&#10;        public boolean isOpen() { return isOpen; }&#10;        public double getRealizedPnL() { return realizedPnL; }&#10;        public LocalDateTime getExitTime() { return exitTime; }&#10;    }&#10;    &#10;    public static class RiskParameters {&#10;        private final double maxDailyLoss;&#10;        private final double maxPositionSize;&#10;        private final double riskPerTrade;&#10;        private final int maxPositions;&#10;        private final double maxPortfolioExposure;&#10;        &#10;        public RiskParameters(double maxDailyLoss, double maxPositionSize, &#10;                            double riskPerTrade, int maxPositions, double maxPortfolioExposure) {&#10;            this.maxDailyLoss = maxDailyLoss;&#10;            this.maxPositionSize = maxPositionSize;&#10;            this.riskPerTrade = riskPerTrade;&#10;            this.maxPositions = maxPositions;&#10;            this.maxPortfolioExposure = maxPortfolioExposure;&#10;        }&#10;        &#10;        public double getMaxDailyLoss() { return maxDailyLoss; }&#10;        public double getMaxPositionSize() { return maxPositionSize; }&#10;        public double getRiskPerTrade() { return riskPerTrade; }&#10;        public int getMaxPositions() { return maxPositions; }&#10;        public double getMaxPortfolioExposure() { return maxPortfolioExposure; }&#10;    }&#10;    &#10;    private final Map&lt;String, Position&gt; openPositions = new ConcurrentHashMap&lt;&gt;();&#10;    private final List&lt;Position&gt; closedPositions = Collections.synchronizedList(new ArrayList&lt;&gt;());&#10;    private final AtomicDouble totalCapital;&#10;    private final RiskParameters riskParams;&#10;    private final AtomicDouble dailyPnL = new AtomicDouble(0);&#10;    &#10;    public PositionManager(double initialCapital, RiskParameters riskParams) {&#10;        this.totalCapital = new AtomicDouble(initialCapital);&#10;        this.riskParams = riskParams;&#10;    }&#10;    &#10;    public int calculatePositionSize(double entryPrice, double stopLoss, String instrumentToken) {&#10;        double riskAmount = totalCapital.get() * (riskParams.getRiskPerTrade() / 100.0);&#10;        double riskPerShare = Math.abs(entryPrice - stopLoss);&#10;        &#10;        if (riskPerShare &lt;= 0) return 0;&#10;        &#10;        int calculatedSize = (int) (riskAmount / riskPerShare);&#10;        double maxPositionValue = totalCapital.get() * (riskParams.getMaxPositionSize() / 100.0);&#10;        int maxAllowedSize = (int) (maxPositionValue / entryPrice);&#10;        &#10;        return Math.min(calculatedSize, maxAllowedSize);&#10;    }&#10;    &#10;    public boolean canOpenPosition(TradingSignal signal) {&#10;        return openPositions.size() &lt; riskParams.getMaxPositions() &amp;&amp;&#10;               dailyPnL.get() &gt; -riskParams.getMaxDailyLoss() &amp;&amp;&#10;               !openPositions.containsKey(signal.getInstrumentToken());&#10;    }&#10;    &#10;    public boolean openPosition(TradingSignal signal) {&#10;        if (!canOpenPosition(signal)) return false;&#10;        &#10;        String transactionType = (signal.getType() == TradingSignal.SignalType.BUY) ? &quot;BUY&quot; : &quot;SELL&quot;;&#10;        Position position = new Position(signal.getInstrumentToken(), transactionType,&#10;                signal.getQuantity(), signal.getTriggerPrice(), signal.getStopLossPrice(), signal.getTargetPrice());&#10;        &#10;        openPositions.put(signal.getInstrumentToken(), position);&#10;        return true;&#10;    }&#10;    &#10;    public List&lt;Position&gt; updatePositions(Map&lt;String, Double&gt; currentPrices) {&#10;        List&lt;Position&gt; positionsToClose = new ArrayList&lt;&gt;();&#10;        &#10;        for (Position position : openPositions.values()) {&#10;            Double currentPrice = currentPrices.get(position.getInstrumentToken());&#10;            if (currentPrice != null) {&#10;                position.updateCurrentPrice(currentPrice);&#10;                if (position.shouldCloseOnStopLoss() || position.shouldCloseOnTarget()) {&#10;                    positionsToClose.add(position);&#10;                }&#10;            }&#10;        }&#10;        return positionsToClose;&#10;    }&#10;    &#10;    public void closePosition(String instrumentToken, double exitPrice, String reason) {&#10;        Position position = openPositions.remove(instrumentToken);&#10;        if (position != null) {&#10;            position.closePosition(exitPrice);&#10;            closedPositions.add(position);&#10;            dailyPnL.addAndGet(position.getRealizedPnL());&#10;            totalCapital.addAndGet(position.getRealizedPnL());&#10;        }&#10;    }&#10;    &#10;    public Map&lt;String, Object&gt; getDailyStats() {&#10;        Map&lt;String, Object&gt; stats = new HashMap&lt;&gt;();&#10;        stats.put(&quot;totalCapital&quot;, totalCapital.get());&#10;        stats.put(&quot;dailyPnL&quot;, dailyPnL.get());&#10;        stats.put(&quot;openPositions&quot;, openPositions.size());&#10;        stats.put(&quot;totalUnrealizedPnL&quot;, openPositions.values().stream().mapToDouble(Position::getUnrealizedPnL).sum());&#10;        stats.put(&quot;portfolioExposure&quot;, openPositions.values().stream().mapToDouble(p -&gt; p.getEntryPrice() * p.getQuantity()).sum());&#10;        stats.put(&quot;closedTradesToday&quot;, closedPositions.size());&#10;        return stats;&#10;    }&#10;    &#10;    public void resetDailyCounters() {&#10;        dailyPnL.set(0);&#10;        closedPositions.clear();&#10;    }&#10;    &#10;    public Map&lt;String, Position&gt; getOpenPositions() { return new HashMap&lt;&gt;(openPositions); }&#10;    public List&lt;Position&gt; getClosedPositions() { return new ArrayList&lt;&gt;(closedPositions); }&#10;    public double getTotalCapital() { return totalCapital.get(); }&#10;    public double getDailyPnL() { return dailyPnL.get(); }&#10;}&#10;" />
              <option name="updatedContent" value="package trading.bot;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.*;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;import java.util.concurrent.atomic.AtomicDouble;&#10;&#10;/**&#10; * Manages trading positions and risk parameters.&#10; */&#10;public class PositionManager {&#10;    /**&#10;     * Represents a trading position.&#10;     */&#10;    public static class Position {&#10;        private final String instrumentToken;&#10;        private final String transactionType;&#10;        private final int quantity;&#10;        private final double entryPrice;&#10;        private final double stopLoss;&#10;        private final double target;&#10;        private final LocalDateTime entryTime;&#10;        private double currentPrice;&#10;        private boolean isOpen = true;&#10;        private double realizedPnL = 0;&#10;        private LocalDateTime exitTime;&#10;&#10;        /**&#10;         * Constructs a Position object.&#10;         */&#10;        public Position(String instrumentToken, String transactionType, int quantity,&#10;                       double entryPrice, double stopLoss, double target) {&#10;            this.instrumentToken = instrumentToken;&#10;            this.transactionType = transactionType;&#10;            this.quantity = quantity;&#10;            this.entryPrice = entryPrice;&#10;            this.stopLoss = stopLoss;&#10;            this.target = target;&#10;            this.entryTime = LocalDateTime.now();&#10;            this.currentPrice = entryPrice;&#10;        }&#10;&#10;        // Getters and setters&#10;        public void updateCurrentPrice(double price) { this.currentPrice = price; }&#10;        public double getUnrealizedPnL() {&#10;            if (!isOpen) return realizedPnL;&#10;            return &quot;BUY&quot;.equals(transactionType) ?&#10;                (currentPrice - entryPrice) * quantity : (entryPrice - currentPrice) * quantity;&#10;        }&#10;        public void closePosition(double exitPrice) {&#10;            this.currentPrice = exitPrice;&#10;            this.realizedPnL = getUnrealizedPnL();&#10;            this.isOpen = false;&#10;            this.exitTime = LocalDateTime.now();&#10;        }&#10;        public boolean shouldCloseOnStopLoss() {&#10;            return isOpen &amp;&amp; ((&quot;BUY&quot;.equals(transactionType) &amp;&amp; currentPrice &lt;= stopLoss) ||&#10;                             (&quot;SELL&quot;.equals(transactionType) &amp;&amp; currentPrice &gt;= stopLoss));&#10;        }&#10;        public boolean shouldCloseOnTarget() {&#10;            return isOpen &amp;&amp; ((&quot;BUY&quot;.equals(transactionType) &amp;&amp; currentPrice &gt;= target) ||&#10;                             (&quot;SELL&quot;.equals(transactionType) &amp;&amp; currentPrice &lt;= target));&#10;        }&#10;        public boolean isOpen() { return isOpen; }&#10;        public String getInstrumentToken() { return instrumentToken; }&#10;        public String getTransactionType() { return transactionType; }&#10;        public int getQuantity() { return quantity; }&#10;        public double getEntryPrice() { return entryPrice; }&#10;        public double getStopLoss() { return stopLoss; }&#10;        public double getTarget() { return target; }&#10;        public LocalDateTime getEntryTime() { return entryTime; }&#10;        public LocalDateTime getExitTime() { return exitTime; }&#10;        public double getCurrentPrice() { return currentPrice; }&#10;        public double getRealizedPnL() { return realizedPnL; }&#10;    }&#10;&#10;    public static class RiskParameters {&#10;        private final double maxDailyLoss;&#10;        private final double maxPositionSize;&#10;        private final double riskPerTrade;&#10;        private final int maxPositions;&#10;        private final double maxPortfolioExposure;&#10;&#10;        /**&#10;         * Constructs RiskParameters object.&#10;         */&#10;        public RiskParameters(double maxDailyLoss, double maxPositionSize,&#10;                            double riskPerTrade, int maxPositions, double maxPortfolioExposure) {&#10;            this.maxDailyLoss = maxDailyLoss;&#10;            this.maxPositionSize = maxPositionSize;&#10;            this.riskPerTrade = riskPerTrade;&#10;            this.maxPositions = maxPositions;&#10;            this.maxPortfolioExposure = maxPortfolioExposure;&#10;        }&#10;&#10;        public double getMaxDailyLoss() { return maxDailyLoss; }&#10;        public double getMaxPositionSize() { return maxPositionSize; }&#10;        public double getRiskPerTrade() { return riskPerTrade; }&#10;        public int getMaxPositions() { return maxPositions; }&#10;        public double getMaxPortfolioExposure() { return maxPortfolioExposure; }&#10;    }&#10;&#10;    private final Map&lt;String, Position&gt; openPositions = new ConcurrentHashMap&lt;&gt;();&#10;    private final List&lt;Position&gt; closedPositions = Collections.synchronizedList(new ArrayList&lt;&gt;());&#10;    private final AtomicDouble totalCapital;&#10;    private final RiskParameters riskParams;&#10;    private final AtomicDouble dailyPnL = new AtomicDouble(0);&#10;&#10;    /**&#10;     * Constructs a PositionManager object.&#10;     */&#10;    public PositionManager(double initialCapital, RiskParameters riskParams) {&#10;        this.totalCapital = new AtomicDouble(initialCapital);&#10;        this.riskParams = riskParams;&#10;    }&#10;&#10;    public int calculatePositionSize(double entryPrice, double stopLoss, String instrumentToken) {&#10;        double riskAmount = totalCapital.get() * (riskParams.getRiskPerTrade() / 100.0);&#10;        double riskPerShare = Math.abs(entryPrice - stopLoss);&#10;&#10;        if (riskPerShare &lt;= 0) return 0;&#10;&#10;        int calculatedSize = (int) (riskAmount / riskPerShare);&#10;        double maxPositionValue = totalCapital.get() * (riskParams.getMaxPositionSize() / 100.0);&#10;        int maxAllowedSize = (int) (maxPositionValue / entryPrice);&#10;&#10;        return Math.min(calculatedSize, maxAllowedSize);&#10;    }&#10;&#10;    public boolean canOpenPosition(TradingSignal signal) {&#10;        return openPositions.size() &lt; riskParams.getMaxPositions() &amp;&amp;&#10;               dailyPnL.get() &gt; -riskParams.getMaxDailyLoss() &amp;&amp;&#10;               !openPositions.containsKey(signal.getInstrumentToken());&#10;    }&#10;&#10;    public boolean openPosition(TradingSignal signal) {&#10;        if (!canOpenPosition(signal)) return false;&#10;&#10;        String transactionType = (signal.getType() == TradingSignal.SignalType.BUY) ? &quot;BUY&quot; : &quot;SELL&quot;;&#10;        Position position = new Position(signal.getInstrumentToken(), transactionType,&#10;                signal.getQuantity(), signal.getTriggerPrice(), signal.getStopLossPrice(), signal.getTargetPrice());&#10;&#10;        openPositions.put(signal.getInstrumentToken(), position);&#10;        return true;&#10;    }&#10;&#10;    public List&lt;Position&gt; updatePositions(Map&lt;String, Double&gt; currentPrices) {&#10;        List&lt;Position&gt; positionsToClose = new ArrayList&lt;&gt;();&#10;&#10;        for (Position position : openPositions.values()) {&#10;            Double currentPrice = currentPrices.get(position.getInstrumentToken());&#10;            if (currentPrice != null) {&#10;                position.updateCurrentPrice(currentPrice);&#10;                if (position.shouldCloseOnStopLoss() || position.shouldCloseOnTarget()) {&#10;                    positionsToClose.add(position);&#10;                }&#10;            }&#10;        }&#10;        return positionsToClose;&#10;    }&#10;&#10;    public void closePosition(String instrumentToken, double exitPrice, String reason) {&#10;        Position position = openPositions.remove(instrumentToken);&#10;        if (position != null) {&#10;            position.closePosition(exitPrice);&#10;            closedPositions.add(position);&#10;            dailyPnL.addAndGet(position.getRealizedPnL());&#10;            totalCapital.addAndGet(position.getRealizedPnL());&#10;        }&#10;    }&#10;&#10;    public Map&lt;String, Object&gt; getDailyStats() {&#10;        Map&lt;String, Object&gt; stats = new HashMap&lt;&gt;();&#10;        stats.put(&quot;totalCapital&quot;, totalCapital.get());&#10;        stats.put(&quot;dailyPnL&quot;, dailyPnL.get());&#10;        stats.put(&quot;openPositions&quot;, openPositions.size());&#10;        stats.put(&quot;totalUnrealizedPnL&quot;, openPositions.values().stream().mapToDouble(Position::getUnrealizedPnL).sum());&#10;        stats.put(&quot;portfolioExposure&quot;, openPositions.values().stream().mapToDouble(p -&gt; p.getEntryPrice() * p.getQuantity()).sum());&#10;        stats.put(&quot;closedTradesToday&quot;, closedPositions.size());&#10;        return stats;&#10;    }&#10;&#10;    public void resetDailyCounters() {&#10;        dailyPnL.set(0);&#10;        closedPositions.clear();&#10;    }&#10;&#10;    public Map&lt;String, Position&gt; getOpenPositions() { return new HashMap&lt;&gt;(openPositions); }&#10;    public List&lt;Position&gt; getClosedPositions() { return new ArrayList&lt;&gt;(closedPositions); }&#10;    public double getTotalCapital() { return totalCapital.get(); }&#10;    public double getDailyPnL() { return dailyPnL.get(); }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>